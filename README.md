## Функциональные React-компоненты

# Работа с состояниями в функциональном компоненте (ФК). 
# hook useState()
# Пример с кликером
1. Для работы с состояниями в ФК нужно импортировать из реакта хук {useState}
2. useState это функция, результатом которой является масив из двух элементов: 
3. первый - это значение, а второй - это функция, которая все время обновляет это значение.
4. сделаем деструктуризацию: const [value, setValue] = useState(0) и передадим значение первого параметра по умолчанию;
5. второй параметр - функцию setValue передадим в обработчик, в параметрах выполним действие setValue(value + 1)
6. При использовании юсСтейта в функцию setValue можно передавать предыдущее значение value. setValue((prevvalue)=>prevvalue + 1)
# Управление жизненным циклом в ФК
1. не все этапы жизненного цикла, которые были в классовом компоненте, мы можем реализовать в ФК, но можем три основных (didMount, didUpdate, didUnmount)
2. заведем кнопку которая будет позаывать/прятать кликер при нажатии. 
# hook useEffect()
1. useEffect отвечает за роботу жизненного цикла
2. так же как и useState, useEffect можем использовать несколько раз
3. useEffect() пишется перед return и ни к чему не присваевается, мы его просто вызваем
4. он принимает 2 параметра. Первый это функция (действия которые мы хотим сделат). А вторая это массив зависимостей []
5. useEffect(()=>{}, [])
6. массив зависимостей это набор условий при которых должен быть вызван колбек.
7. если массив пустой то колбек выполнится один раз. произойдет монтирование (didMount)
8. добавим в массив зависимостей count. теперь теперь колбек будет выполняться постоянно при изменении count (didUpdate)
9. если в колбеке добавить return, и вывести внем что-то. то произойдет размонтирование (didUnmount)
# Использование рефов в функциональном компоненте
# hook useRef
1. установим каренту 0 и при клике на кнопку попробуем увеличить значение на 1
2. как видим при клике ничего не происходит, не обновляется значение карента на 1
3. это побочный эффект хука юсРеф, при использовании которого не происходит перерендер.
## Хуки подробно
# useState
    const [value, setValue] = useState()
1.  в useState() обычно мы либо записываем либо передаем в круглые скобки какое-то значение по умолчанию
2.  также рассматривали вариант когда передавали туда функцию useState((preValue) => {return preValue + 1}), 
    которая брала значени, выполняла с ним действие и возвращала новое значение.
3.  useState позволяет задать значение по умолчанию в виде функции колбек и выполнить ее внутри себя:
    const [value, setValue] = useState(() => {
    const userCount = localStorage.getItem('count');
    return +userCount || 0;
    вернет либо последнее значение из локала (переведенной в число) либо 0
    })
# UseEffect
1.  UseEffect всегда асинхронный
2.  он всегда вызывается по умолчанию при каких либо изменениях.
3.  чтобы этого избежать нужно передать зависимость (в массив зависимостей)
    тогда он будет запускаться при обновлении зависимости
4.  юзэффектов может быть много на странице
    когда их много на странице, и чтобы не запутаться кто что делает принята над каждым оставлять комментарий
    useEffect(()=>{}, [])
    useEffect(()=>{}, [])
    либо вместо стрелочной ации пишут обычную и название описывает работу ф-ции
    useEffect(function isLoading() {}, [])
5.  добавляем и удяляем обработчик с узла
    useEffect(()=>{
        монтируем
    const handler = ()=>{};
    document.addEventListener('click', handler)
        размонтируем
    return ()=>{
        document.removeEventListener('click', handler)
        }
    }, [])
6.  если массив зависимосте пустой, то функция размонтирования отработает также как и ф-ция монтирования - один раз.
# useContext
1. очень мощный хук, позволяющий пробрасывать пропсы в любое место, любому дочернему элементу, любой вложености без использования пропсов.
# uselayoutEffect
1. этот хук по своим свойствам похож на useEffect, разници лишь в том что useEffect - асинхронный, а uselayoutEffect - синхронный
2. финальная отрисовка дом елемента будет один раз. но при этом может быть несколько виртуальных ренденов внутри uselayoutEffect
3. пока все рендеры не произойдут финального не будет, поэтому приложение может притормаживать
4. используется когда нужно принудительно что-то поменять в доме
5. рекомендуется использовать асинхронный useEffect.
# useCallback
# useMemo
1. useCallback возвращает нам мемоизированную функцию, а useMemo возвращает значение функции.
2. оба хука принимают функцию и массив зависимостей.

